// Generated by CoffeeScript 1.6.3
(function() {
  var OauthAuthMethods, PageResult, passgen, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore-ext');

  PageResult = require('simple-paginator').PageResult;

  passgen = require('passgen');

  /*
  Provides methods to interact with the auth store.
  */


  module.exports = OauthAuthMethods = (function() {
    var TENMINUTESINSECONDS, TENYEARSINSECONDS;

    TENYEARSINSECONDS = 60 * 60 * 24 * 365 * 10;

    TENMINUTESINSECONDS = 60 * 10;

    /*
    Returns the current date + seconds
    @param {Number} seconds The seconds, or if null then roughly 10 years is assumed.
    */


    OauthAuthMethods.prototype.currentDateAndSeconds = function(seconds) {
      var now;
      if (seconds == null) {
        seconds = TENYEARSINSECONDS;
      }
      now = new Date();
      now.setSeconds(now.getSeconds() + seconds);
      return now;
    };

    /*
    Initializes a new instance of the @see AuthMethods class.
    @param {Object} models A collection of models to be used within the auth framework.
    */


    function OauthAuthMethods(models) {
      this.models = models;
      this.exchangeRefreshTokenForAccessToken = __bind(this.exchangeRefreshTokenForAccessToken, this);
      this.exchangeAuthorizationCodeForAccessToken = __bind(this.exchangeAuthorizationCodeForAccessToken, this);
      this.createTokenForUserId = __bind(this.createTokenForUserId, this);
      this.createOrReuseTokenForUserId = __bind(this.createOrReuseTokenForUserId, this);
      this.createAccessGrant = __bind(this.createAccessGrant, this);
      this.validate = __bind(this.validate, this);
      this.appForClientId = __bind(this.appForClientId, this);
      this.currentDateAndSeconds = __bind(this.currentDateAndSeconds, this);
      if (!this.models) {
        throw new Error("models parameter is required");
      }
    }

    /*
    Retrieves an app for a key. This ONLY retrieves active keys
    @param {string} appKey the application key to retrieve the app for.
    */


    OauthAuthMethods.prototype.appForClientId = function(clientId, cb) {
      var _this = this;
      if (!clientId) {
        return cb(new Error("clientId parameter missing in appForClientId"));
      }
      return this.models.OauthApp.findOne({
        'clients.clientId': clientId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    /*
    Somehow validates a token. A valid token exists, has not been revoked yet,
    has an expiration higher than now.
    isClientValid can be checked for tighter security.
    */


    OauthAuthMethods.prototype.validate = function(token, clientId, cb) {
      var _this = this;
      return this.models.OauthAccessToken.findOne({
        _id: token
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(null, {
            isValid: false
          });
        }
        return cb(null, {
          isValid: !item.revoked,
          isClientValid: true,
          actor: {
            actorId: item.identityUserId
          },
          clientId: clientId,
          scopes: item.scope || [],
          expiresIn: 10000
        });
      });
    };

    /*
    Creates a new access grant.
    @param {String || ObjectId} appId the mongoose app id.
    @param {String || ObjectId} userId the mongoose user id
    @param {String} redirectUrl the requested redirect_uri. This must be later matched when issuing an access token.
    @param {String[]} scope an array of strings, with one or more elements, specifying the scope that should be granted.
    @param {String} realm an optional realm for which this access grant is for.
    @param {Callback} cb the callback that will be invoked, with err and the mongoose AccessGrant model.
    */


    OauthAuthMethods.prototype.createAccessGrant = function(appId, userId, redirectUrl, scope, realm, cb) {
      var accessGrant,
        _this = this;
      if (realm == null) {
        realm = null;
      }
      if (!userId) {
        return cb(new Error("userId parameter missing in createAccessGrant"));
      }
      if (!appId) {
        return cb(new Error("appId parameter missing in createAccessGrant"));
      }
      if (!redirectUrl) {
        return cb(new Error("redirectUrl parameter missing in createAccessGrant"));
      }
      if (!(scope && scope.length > 0)) {
        return cb(new Error("scope parameter missing in createAccessGrant"));
      }
      accessGrant = new this.models.OauthAccessGrant({
        appId: appId,
        identityUserId: userId,
        realm: realm,
        redirectUrl: redirectUrl,
        scope: scope,
        expiresAt: this.currentDateAndSeconds(TENMINUTESINSECONDS)
      });
      return accessGrant.save(function(err) {
        if (err) {
          return cb(err);
        }
        return cb(null, accessGrant);
      });
    };

    /*
    Creates a token for a user/app/realm
    */


    OauthAuthMethods.prototype.createOrReuseTokenForUserId = function(userId, clientId, realm, scope, expiresIn, cb) {
      return this.createTokenForUserId(userId, clientId, realm, scope, expiresIn, cb);
    };

    /*
    Creates a token for a user/app/realm
    */


    OauthAuthMethods.prototype.createTokenForUserId = function(userId, clientId, realm, scope, expiresIn, cb) {
      var _this = this;
      if (realm == null) {
        realm = null;
      }
      if (scope == null) {
        scope = null;
      }
      if (expiresIn == null) {
        expiresIn = null;
      }
      return this.appForClientId(clientId, function(err, app) {
        var token;
        if (err) {
          return cb(err);
        }
        if (!app) {
          return cb(new Error("Could not find app for clientId " + clientId));
        }
        token = new _this.models.OauthAccessToken({
          appId: app._id,
          identityUserId: userId,
          realm: realm,
          expiresAt: _this.currentDateAndSeconds(expiresIn || 3600),
          scope: scope && scope.length > 0 ? scope : app.scopes
        });
        return token.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, token);
        });
      });
    };

    /*
    Takes a code and exchanges it for an access token
    @param {String} code the authorization_code to exchange into an access token
    */


    OauthAuthMethods.prototype.exchangeAuthorizationCodeForAccessToken = function(code, cb) {
      var _this = this;
      return this.models.OauthAccessGrant.findOne({
        _id: code
      }, function(err, accessGrant) {
        var token;
        if (err) {
          return cb(err);
        }
        if (!accessGrant) {
          return cb(new Error("NOT FOUND"));
        }
        token = new _this.models.OauthAccessToken({
          appId: accessGrant.appId,
          identityUserId: accessGrant.userId,
          realm: accessGrant.realm,
          expiresAt: _this.currentDateAndSeconds(3600),
          scope: accessGrant.scope
        });
        return token.save(function(err) {
          if (err) {
            return cb(err);
          }
          accessGrant.revokedAt = new Date();
          accessGrant.accessToken = token._id;
          return accessGrant.save(function(err) {
            if (err) {
              return cb(err);
            }
            return cb(null, token);
          });
        });
      });
    };

    /*
    Takes a code and exchanges it for an access token
    @param {String} refreshToken the refresh_token to exchange into an access token
    */


    OauthAuthMethods.prototype.exchangeRefreshTokenForAccessToken = function(refreshToken, cb) {
      var _this = this;
      return this.models.OauthAccessToken.findOne({
        refreshToken: refreshToken
      }, function(err, token) {
        if (err) {
          return cb(err);
        }
        if (!token) {
          return cb(new Error("NOT FOUND 2"));
        }
        token.refreshToken = null;
        return token.save(function(err) {
          var newToken;
          if (err) {
            return cb(err);
          }
          newToken = new _this.models.OauthAccessToken({
            appId: token.appId,
            identityUserId: token.userId,
            realm: token.realm,
            expiresAt: _this.currentDateAndSeconds(3600),
            scope: token.scope
          });
          return newToken.save(function(err) {
            if (err) {
              return cb(err);
            }
            return cb(null, newToken);
          });
        });
      });
    };

    /*
    getUserIdForAccessTokenString: (accessTokenString, cb) =>
        cb(null)
    
    
    
    listAccessTokens: (cb) =>
      cb(null)
    */


    return OauthAuthMethods;

  })();

}).call(this);
