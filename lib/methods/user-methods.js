// Generated by CoffeeScript 1.4.0
(function() {
  var ObjectId, PageResult, UserMethods, bcrypt, errors, isObjectId, mongoose, passgen, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore-ext');

  errors = require('some-errors');

  PageResult = require('simple-paginator').PageResult;

  mongoose = require("mongoose");

  ObjectId = mongoose.Types.ObjectId;

  bcrypt = require('bcrypt');

  passgen = require('passgen');

  isObjectId = require('mongodb-objectid-helper').isObjectId;

  require('date-utils');

  /*
  Provides methods to interact with scotties.
  */


  module.exports = UserMethods = (function() {
    var UPDATE_FIELDS_FULL, resetPasswordTokenLength;

    UPDATE_FIELDS_FULL = ['username', 'description', 'displayName', 'identities', 'primaryEmail', 'profileLinks', 'userImages', 'selectedUserImage', 'emails', 'roles', 'data', 'resourceLimits', 'onboardingState', 'title', 'location', 'needsInit'];

    /*
      Initializes a new instance of the {UserMethods} class.
      @param {Object} models A collection of models that can be used.
    */


    function UserMethods(models) {
      this.models = models;
      this.removeEmail = __bind(this.removeEmail, this);

      this.addEmail = __bind(this.addEmail, this);

      this.resetPasswordToken = __bind(this.resetPasswordToken, this);

      this.resetPassword = __bind(this.resetPassword, this);

      this.removeRoles = __bind(this.removeRoles, this);

      this.addRoles = __bind(this.addRoles, this);

      this.removeIdentityFromUser = __bind(this.removeIdentityFromUser, this);

      this.addIdentityToUser = __bind(this.addIdentityToUser, this);

      this._profileImageFromProfile = __bind(this._profileImageFromProfile, this);

      this._displayNameFromProfile = __bind(this._displayNameFromProfile, this);

      this._usernameFromProfile = __bind(this._usernameFromProfile, this);

      this.getOrCreateUserFromProvider = __bind(this.getOrCreateUserFromProvider, this);

      this.create = __bind(this.create, this);

      this.hashPassword = __bind(this.hashPassword, this);

      this.validateUserByUsernameOrEmail = __bind(this.validateUserByUsernameOrEmail, this);

      this.findUserByUsernameOrEmail = __bind(this.findUserByUsernameOrEmail, this);

      this.setPassword = __bind(this.setPassword, this);

      this.destroy = __bind(this.destroy, this);

      this["delete"] = __bind(this["delete"], this);

      this.patch = __bind(this.patch, this);

      this.getByNameOrId = __bind(this.getByNameOrId, this);

      this.getByPrimaryEmail = __bind(this.getByPrimaryEmail, this);

      this.getByName = __bind(this.getByName, this);

      this.lookup = __bind(this.lookup, this);

      this.get = __bind(this.get, this);

      this.getByUsernames = __bind(this.getByUsernames, this);

      this.getByIds = __bind(this.getByIds, this);

      this.all = __bind(this.all, this);

      if (!this.models) {
        throw new Error("models parameter is required");
      }
    }

    UserMethods.prototype.all = function(offset, count, cb) {
      var _this = this;
      if (offset == null) {
        offset = 0;
      }
      if (count == null) {
        count = 25;
      }
      return this.models.User.count(function(err, totalCount) {
        if (err) {
          return cb(err);
        }
        return _this.models.User.find({}, null, {
          skip: offset,
          limit: count
        }, function(err, items) {
          if (err) {
            return cb(err);
          }
          return cb(null, new PageResult(items || [], totalCount, offset, count));
        });
      });
    };

    /*
      Retrieves users by passing a list of id's, which can be string or objectIds
    */


    UserMethods.prototype.getByIds = function(idList, cb) {
      var _this = this;
      if (idList == null) {
        idList = [];
      }
      idList = _.map(idList, function(x) {
        return new ObjectId(x.toString());
      });
      return this.models.User.find({}).where('_id')["in"](idList).exec(function(err, items) {
        if (err) {
          return cb(err);
        }
        items || (items = []);
        return cb(null, new PageResult(items, items.length, 0, 99999999));
      });
    };

    /*
      Retrieves users by passing a list of usernames.
      @param {[String]} usernames an array of usernames. Case insensitive
      @param {Object} options a set of options, which can be null
      @param {Function} cb a callback that is invoked after completion of this method.
      @option options [String] select the space separated fields to return, which default to all.
    */


    UserMethods.prototype.getByUsernames = function(usernames, options, cb) {
      var query,
        _this = this;
      if (usernames == null) {
        usernames = [];
      }
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      usernames = _.map(usernames, function(x) {
        return x.toLowerCase();
      });
      query = this.models.User.find({}).where('username')["in"](usernames);
      if (options.select && options.select.length > 0) {
        query = query.select(options.select);
      }
      return query.exec(function(err, items) {
        if (err) {
          return cb(err);
        }
        items || (items = []);
        return cb(null, new PageResult(items, items.length, 0, usernames.length));
      });
    };

    /*
      Looks up a user by id.
    */


    UserMethods.prototype.get = function(id, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      id = new ObjectId(id.toString());
      return this.models.User.findOne({
        _id: id
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    /*
      Returns a list of users who match q. In this version we do a straight user name match.
      @param {String} q a search string.
      @param {Object} options a set of options, which can be null
      @param {Function} cb a callback that is invoked after completion of this method.
      @option options [Integer] limit the maximum number of results to return, defaults to 10.
      @option options [String] sortOrder the sort order in mongodb syntax, which defaults to 'username'.
      @option options [String] select the space separated fields to return, which default to '_id username displayName selectedUserImage'.
    */


    UserMethods.prototype.lookup = function(q, options, cb) {
      var r,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      q = (q || '').toLowerCase().trim();
      options.limit || (options.limit = 10);
      options.sortOrder || (options.sortOrder = 'username');
      options.select || (options.select = '_id username displayName selectedUserImage');
      r = new RegExp("^" + q);
      return this.models.User.find({
        username: r
      }).select(options.select).sort(options.sortOrder).limit(options.limit).exec(function(err, items) {
        if (err) {
          return cb(err);
        }
        items || (items = []);
        return cb(null, new PageResult(items, items.length, 0, items.length));
      });
    };

    UserMethods.prototype.getByName = function(name, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      name = name.toLowerCase();
      return this.models.User.findOne({
        username: name
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    UserMethods.prototype.getByPrimaryEmail = function(email, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      email = email.toLowerCase();
      return this.models.User.findOne({
        primaryEmail: email
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        return cb(null, item);
      });
    };

    UserMethods.prototype.getByNameOrId = function(nameOrId, cb) {
      if (cb == null) {
        cb = function() {};
      }
      if (isObjectId(nameOrId)) {
        return this.get(nameOrId, cb);
      } else {
        return this.getByName(nameOrId, cb);
      }
    };

    UserMethods.prototype.patch = function(usernameOrId, obj, actor, cb) {
      var _this = this;
      if (obj == null) {
        obj = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      return this.getByNameOrId(usernameOrId, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + usernameOrId));
        }
        _.extendFiltered(item, UPDATE_FIELDS_FULL, obj);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          if (obj.password) {
            return _this.setPassword(usernameOrId, obj.password, actor, function(err, item2) {
              if (err) {
                return cb(err);
              }
              return cb(null, item);
            });
          } else {
            return cb(null, item);
          }
        });
      });
    };

    UserMethods.prototype["delete"] = function(usernameOrId, actor, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      return this.getByNameOrId(usernameOrId, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + usernameOrId));
        }
        if (item.isDeleted) {
          return cb(null);
        }
        item.isDeleted = true;
        item.deletedAt = new Date();
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item);
        });
      });
    };

    UserMethods.prototype.destroy = function(usernameOrId, actor, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      return this.getByNameOrId(usernameOrId, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + usernameOrId));
        }
        return item.remove(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item);
        });
      });
    };

    UserMethods.prototype.setPassword = function(usernameOrId, password, actor, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      return this.getByNameOrId(usernameOrId, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + usernameOrId));
        }
        return _this.hashPassword(password, function(err, hash) {
          if (err) {
            return cb(err);
          }
          item.password = hash;
          return item.save(function(err) {
            if (err) {
              return cb(err);
            }
            return cb(null, item);
          });
        });
      });
    };

    /*
      Looks up a user by username or email.
    */


    UserMethods.prototype.findUserByUsernameOrEmail = function(usernameOrEmail, cb) {
      var _this = this;
      usernameOrEmail = usernameOrEmail.toLowerCase();
      return this.models.User.findOne({
        username: usernameOrEmail
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (item) {
          return cb(null, item);
        }
        return _this.models.User.findOne({
          primaryEmail: usernameOrEmail
        }, function(err, item) {
          if (err) {
            return cb(err);
          }
          return cb(null, item);
        });
      });
    };

    /*
      Looks up the user, if found validates against password.
      cb(err) in case of non password error.
      cb(null, user) in case of user not found, password not valid, or valid user
    */


    UserMethods.prototype.validateUserByUsernameOrEmail = function(usernameOrEmail, password, cb) {
      var _this = this;
      usernameOrEmail = usernameOrEmail.toLowerCase();
      return this.findUserByUsernameOrEmail(usernameOrEmail, function(err, user) {
        if (err) {
          return cb(err);
        }
        if (!user) {
          return cb(null, null);
        }
        return bcrypt.compare(password, user.password, function(err, res) {
          if (err) {
            return cb(err);
          }
          if (!res) {
            return cb(null, null);
          }
          return cb(null, user);
        });
      });
    };

    UserMethods.prototype.hashPassword = function(password, cb) {
      var _this = this;
      return bcrypt.genSalt(10, function(err, salt) {
        if (err) {
          return cb(err);
        }
        return bcrypt.hash(password, salt, function(err, hash) {
          if (err) {
            return cb(err);
          }
          return cb(null, hash);
        });
      });
    };

    /*
      Creates a new user.
    */


    UserMethods.prototype.create = function(objs, cb) {
      var user,
        _this = this;
      if (objs == null) {
        objs = {};
      }
      _.defaults(objs, {
        username: null,
        primaryEmail: null,
        password: null
      });
      if (objs.email && !objs.primaryEmail) {
        objs.primaryEmail = objs.email;
      }
      delete objs.email;
      user = new this.models.User(objs);
      if (objs.primaryEmail) {
        user.emails = [objs.primaryEmail];
      }
      /*
          var gravatar = require('gravatar');
          var url = gravatar.url('emerleite@gmail.com', {s: '200', r: 'pg', d: '404'});
      */

      return this.hashPassword(objs.password, function(err, hash) {
        if (err) {
          return cb(err);
        }
        user.password = hash;
        return user.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, user);
        });
      });
    };

    /*
      Gets or creates a user for a given provider/profile combination.
      @param {String} provider a provider string like "facebook" or "twitter".
      @param {String} v1 the key or access_token, depending on the type of provider
      @param {String} v2 the secret or refresh_token, depending on the type of provider
      @param {Object} profile The profile as defined here: http://passportjs.org/guide/user-profile.html
    */


    UserMethods.prototype.getOrCreateUserFromProvider = function(provider, v1, v2, profile, cb) {
      var identityQuery, isNew,
        _this = this;
      if (!(profile && profile.id)) {
        return cb(new Error("An id parameter within profile is required."));
      }
      identityQuery = {
        'identities.provider': provider,
        'identities.key': profile.id
      };
      isNew = false;
      return this.models.User.findOne(identityQuery, function(err, item) {
        var identity, isUserNameValid, pusername, _i, _len, _ref;
        if (err) {
          return cb(err);
        }
        if (item) {
          _ref = item.identities;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            identity = _ref[_i];
            if (identity.provider === provider) {
              identity.v1 = v1;
              identity.v2 = v2;
            }
          }
          return item.save(function(err) {
            if (err) {
              return cb(err);
            }
            return cb(null, item, {
              isNew: isNew
            });
          });
        } else {
          isNew = true;
          isUserNameValid = true;
          pusername = profile.username || ("fb" + profile.id);
          return _this.models.User.findOne({
            username: pusername
          }, function(err, itemXX) {
            var email, emails, imageUrl, images, newIdentity, _j, _k, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5;
            if (err) {
              return cb(err);
            }
            isUserNameValid = !itemXX;
            /*
                      { "_json" : { "email" : "martin@wawrusch.com",
                  "favorite_athletes" : [ { "id" : "69025400418",
                        "name" : "Kobe Bryant"
                      },
                      { "id" : "34778334225",
                        "name" : "Kelly Slater"
                      }
                    ],
                  "favorite_teams" : [ { "id" : "144917055340",
                        "name" : "LA Lakers"
                      } ],
                  "first_name" : "Martin",
                  "gender" : "male",
                  "id" : "679841881",
                  "last_name" : "Wawrusch",
                  "link" : "http://www.facebook.com/martinw",
                  "locale" : "en_US",
                  "location" : { "id" : "109434625742337",
                      "name" : "West Hollywood, California"
                    },
                  "name" : "Martin Wawrusch",
                  "timezone" : -8,
                  "updated_time" : "2012-10-31T18:05:42+0000",
                  "username" : "martinw",
                  "verified" : true
                },
              "_raw" : "{\"id\":\"679841881\",\"name\":\"Martin Wawrusch\",\"first_name\":\"Martin\",\"last_name\":\"Wawrusch\",\"link\":\"http:\\/\\/www.facebook.com\\/martinw\",\"username\":\"martinw\",\"location\":{\"id\":\"109434625742337\",\"name\":\"West Hollywood, California\"},\"favorite_teams\":[{\"id\":\"144917055340\",\"name\":\"LA Lakers\"}],\"favorite_athletes\":[{\"id\":\"69025400418\",\"name\":\"Kobe Bryant\"},{\"id\":\"34778334225\",\"name\":\"Kelly Slater\"}],\"gender\":\"male\",\"email\":\"martin\\u0040wawrusch.com\",\"timezone\":-8,\"locale\":\"en_US\",\"verified\":true,\"updated_time\":\"2012-10-31T18:05:42+0000\"}",
              "displayName" : "Martin Wawrusch",
              "emails" : [ { "value" : "martin@wawrusch.com" } ],
              "gender" : "male",
              "id" : "679841881",
              "name" : { "familyName" : "Wawrusch",
                  "givenName" : "Martin"
                },
              "profileUrl" : "http://www.facebook.com/martinw",
              "provider" : "facebook",
              "username" : "martinw"
            }
            */

            item = new _this.models.User;
            item.username = (isUserNameValid ? pusername : pusername + passgen.create(4)).toLowerCase();
            item.displayName = profile.displayName || item.username || pusername;
            item.data = {};
            item.description = profile.description || '';
            item.title = "";
            images = [];
            if (provider === 'twitter' && profile.photos && _.isArray(profile.photos)) {
              images = profile.photos;
            }
            if (profile.username && provider === "facebook") {
              images.push("https://graph.facebook.com/" + (profile.username || profile.id) + "/picture");
            }
            for (_j = 0, _len1 = images.length; _j < _len1; _j++) {
              imageUrl = images[_j];
              item.userImages.push(new _this.models.UserImage({
                url: imageUrl
              }));
            }
            if (profile.profile_image_url && profile.profile_image_url.length > 5) {
              item.selectedUserImage = profile.profile_image_url;
            } else {
              if (images.length > 0) {
                item.selectedUserImage = images[0];
              }
            }
            if (provider === "facebook" && profile.profileUrl) {
              item.profileLinks.push(new _this.models.UserProfile({
                linkUrl: profile.profileUrl,
                linkIdentifier: profile.id,
                provider: provider,
                linkType: 'social',
                linkSubType: 'primary',
                caption: "Facebook",
                isPublic: true
              }));
            }
            if (provider === "twitter") {
              item.profileLinks.push(new _this.models.UserProfile({
                linkUrl: "https://twitter.com/" + profile.username,
                linkIdentifier: profile.username,
                provider: provider,
                linkType: 'social',
                linkSubType: 'primary',
                caption: "Twitter",
                isPublic: true
              }));
            }
            emails = [];
            if (profile.emails && _.isArray(profile.emails)) {
              emails = _.map(profile.emails, function(x) {
                return x.value;
              });
            }
            for (_k = 0, _len2 = emails.length; _k < _len2; _k++) {
              email = emails[_k];
              item.emails.push(new _this.models.Email({
                email: email.toLowerCase(),
                isVerified: true,
                sendNotifications: false
              }));
            }
            if (item.emails.length > 0) {
              item.primaryEmail = item.emails[0].email.toLowerCase();
            }
            item.location = (_ref1 = profile._json) != null ? (_ref2 = _ref1.location) != null ? _ref2.name : void 0 : void 0;
            item.needsInit = !profile.username || !item.primaryEmail || item.primaryEmail.toLowerCase().indexOf("facebook.com") > 0;
            item.gender = profile.gender;
            item.timezone = (_ref3 = profile._json) != null ? _ref3.timezone : void 0;
            item.locale = (_ref4 = profile._json) != null ? _ref4.locale : void 0;
            item.verified = (_ref5 = profile._json) != null ? _ref5.verified : void 0;
            item.roles = ['user-needs-setup'];
            newIdentity = new _this.models.UserIdentity({
              provider: provider,
              key: profile.id,
              v1: v1,
              v2: v2,
              providerType: "oauth",
              username: item.username,
              displayName: item.displayName,
              profileImage: item.selectedUserImage
            });
            item.identities.push(newIdentity);
            return item.save(function(err) {
              if (err) {
                return cb(err);
              }
              return cb(null, item, {
                isNew: isNew
              }, newIdentity);
            });
          });
        }
      });
    };

    UserMethods.prototype._usernameFromProfile = function(profile) {
      return profile.username || '';
    };

    UserMethods.prototype._displayNameFromProfile = function(profile) {
      if (profile.displayName) {
        return profile.displayName;
      }
      if (profile.name && profile.name.givenName && profile.name.familyName) {
        return "" + profile.name.givenName + " " + profile.name.familyName;
      }
      if (profile.name && profile.name.familyName) {
        return profile.name.familyName;
      }
      return profile.username;
    };

    UserMethods.prototype._profileImageFromProfile = function(profile) {
      var raw;
      if (profile.username && profile.provider === "facebook") {
        return "https://graph.facebook.com/" + profile.username + "/picture";
      }
      if (profile.provider === 'twitter' && profile.photos && _.isArray(profile.photos) && profile.photos.length > 0) {
        return profile.photos[0].value;
      }
      if (profile.provider === 'instagram') {
        try {
          raw = JSON.parse(profile._raw);
          return raw.data.profile_picture;
        } catch (e) {
          return null;
        }
      }
      if (profile.provider === 'foursquare') {
        try {
          raw = JSON.parse(profile._raw);
          return raw.response.user.photo;
        } catch (e) {
          return null;
        }
      }
      return null;
    };

    /*
      Adds an identity to an existing user. In this version, it replaces an 
      existing provider of the same type.
      @param {String/ObjectId} userId the id of the user to add this identity to.
      @param {String} provider a provider string like "facebook" or "twitter".
      @param {String} v1 the key or access_token, depending on the type of provider
      @param {String} v2 the secret or refresh_token, depending on the type of provider
      @param {Object} profile The profile as defined here: http://passportjs.org/guide/user-profile.html
    */


    UserMethods.prototype.addIdentityToUser = function(userId, provider, v1, v2, profile, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(new Error("A userId is required"));
      }
      if (!provider) {
        return cb(new Error("A provider is required"));
      }
      if (!v1) {
        return cb(new Error("A v1 is required"));
      }
      if (!profile) {
        return cb(new Error("A profile is required"));
      }
      if (!(profile && profile.id)) {
        return cb(new Error("An id parameter within profile is required."));
      }
      userId = new ObjectId(userId.toString());
      provider = provider.toLowerCase();
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        var existing, newIdentity;
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        existing = _.find(item.identities, function(x) {
          return x.provider === provider;
        });
        if (existing) {
          existing.remove();
        }
        newIdentity = new _this.models.UserIdentity({
          provider: provider,
          key: profile.id,
          v1: v1,
          v2: v2,
          providerType: "oauth",
          username: _this._usernameFromProfile(profile),
          displayName: _this._displayNameFromProfile(profile),
          profileImage: _this._profileImageFromProfile(profile)
        });
        item.identities.push(newIdentity);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item, newIdentity);
        });
      });
    };

    UserMethods.prototype.removeIdentityFromUser = function(userId, identityId, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(new Error("A userId is required"));
      }
      if (!identityId) {
        return cb(new Error("A identityId is required"));
      }
      userId = new ObjectId(userId.toString());
      identityId = new ObjectId(identityId.toString());
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        var existing;
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        existing = item.identities.id(identityId);
        if (existing) {
          existing.remove();
        }
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item);
        });
      });
    };

    UserMethods.prototype.addRoles = function(userId, roles, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(errors.UnprocessableEntity("userId"));
      }
      if (!(roles && roles.length > 0)) {
        return cb(errors.UnprocessableEntity("roles"));
      }
      userId = new ObjectId(userId.toString());
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        item.roles = _.union(item.roles || [], roles);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item.roles, item);
        });
      });
    };

    UserMethods.prototype.removeRoles = function(userId, roles, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(errors.UnprocessableEntity("userId"));
      }
      if (!(roles && roles.length > 0)) {
        return cb(errors.UnprocessableEntity("roles"));
      }
      userId = new ObjectId(userId.toString());
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        item.roles = _.difference(item.roles || [], roles);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item.roles, item);
        });
      });
    };

    resetPasswordTokenLength = 10;

    UserMethods.prototype.resetPassword = function(email, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!email) {
        return cb(new errors.UnprocessableEntity("email"));
      }
      return this.getByPrimaryEmail(email, function(err, user) {
        var newToken;
        if (err) {
          return cb(err);
        }
        if (!user) {
          return cb(new errors.NotFound(""));
        }
        newToken = passgen.create(resetPasswordTokenLength) + user._id.toString() + passgen.create(resetPasswordTokenLength);
        user.resetPasswordToken = {
          token: newToken,
          validTill: (new Date()).add({
            days: 1
          })
        };
        console.log("E");
        return user.save(function(err) {
          console.log("F");
          console.log("G");
          return cb(null, user, newToken);
        });
      });
    };

    UserMethods.prototype.resetPasswordToken = function(token, password, cb) {
      var userId,
        _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!token) {
        return cb(errors.UnprocessableEntity("token"));
      }
      if (!password) {
        return cb(errors.UnprocessableEntity("password"));
      }
      userId = token.substr(resetPasswordTokenLength, token.length - 2 * resetPasswordTokenLength);
      userId = new ObjectId(userId);
      return this.hashPassword(password, function(err, hash) {
        if (err) {
          return cb(err);
        }
        return _this.models.User.findOne({
          _id: userId
        }, function(err, user) {
          if (err) {
            return cb(err);
          }
          if (!user) {
            return cb(new errors.NotFound("/users/" + userId));
          }
          if (!user.resetPasswordToken) {
            return cb(new errors.UnprocessableEntity('token'));
          }
          if ((user.resetPasswordToken.token || '').toLowerCase() !== token.toLowerCase()) {
            return cb(new errors.UnprocessableEntity('token'));
          }
          if (!(user.resetPasswordToken.validTill && user.resetPasswordToken.validTill.isAfter(new Date()))) {
            return cb(new errors.UnprocessableEntity('validTill'));
          }
          user.resetPasswordToken = null;
          user.password = hash;
          return user.save(function(err) {
            if (err) {
              return cb(err);
            }
            return cb(null, user);
          });
        });
      });
    };

    UserMethods.prototype.addEmail = function(userId, email, isValidated, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(errors.UnprocessableEntity("userId"));
      }
      if (!email) {
        return cb(errors.UnprocessableEntity("email"));
      }
      userId = new ObjectId(userId.toString());
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        item.emails = _.union(item.emails || [], [email]);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item.emails, item);
        });
      });
    };

    UserMethods.prototype.removeEmail = function(userId, email, cb) {
      var _this = this;
      if (cb == null) {
        cb = function() {};
      }
      if (!userId) {
        return cb(new errors.UnprocessableEntity("userId"));
      }
      if (!(roles && roles.length > 0)) {
        return cb(new errors.UnprocessableEntity("email"));
      }
      userId = new ObjectId(userId.toString());
      return this.models.User.findOne({
        _id: userId
      }, function(err, item) {
        if (err) {
          return cb(err);
        }
        if (!item) {
          return cb(new errors.NotFound("/users/" + userId));
        }
        item.emails = _.difference(item.emails || [], [email]);
        return item.save(function(err) {
          if (err) {
            return cb(err);
          }
          return cb(null, item.emails, item);
        });
      });
    };

    return UserMethods;

  })();

}).call(this);
